/** Per prima cosa procedo a spiegare la mia idea della soluzione del punto 1.
"Testo del problema: Algebric Identity x+0=0+x=x"
Parto da qui, la mia prima idea è quella di prendere il blocco e scorrere tutte le linee di istruzioni.
Per ogni istruzione, vado a controllare se c'è il valore 0(che è un valore costante, ovvero ConstantInt).
Se c'è lo zero, devo sostituire tutta la istruzione solo con il valore dell'altro operando.
PS Uso come base il file LocalOpts, ma lo svuoto completamente di tutto il codice del prof e ci metto dentro solo il mio**/

#include "llvm/Transforms/Utils/LocalOpts.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/InstrTypes.h"

//Temo che ci vorranno degli include in più, ma non so quali potrebbero essere

using namespace llvm;

bool runOnBasicBlock(BasicBlock &B) {
    //Parto prendendo il basic block
        //Ne scorro tutte le istruzioni
            for (auto &Inst : B) {
                //Ora controllo che la mia sia una operazione
                if (auto *BinOp = dyn_cast<BinaryOperator>(&Inst)) {
                    //controllo che l'operando sia un add
                    if (BinOp->getOpcode() == Instruction::Add) {
                        //Prima controllo se è nella forma "0+x"
                        if (ConstantInt *CI = dyn_cast<ConstantInt>(BinOp->getOperand(0))) {
                            if (CI->isZero()) {
                                //Mi salvo il valore della x in una variabile Value
                                Value *X = BinOp->getOperand(1);
                                //Rimpiazzo tutte le occorrenze con la x stessa
                                BinOp->replaceAllUsesWith(X);
                                //cancello la riga di istruzione
                                BinOp->eraseFromParent();
                                return true;
                            }
                        } 
                        //Ora controllo se è nella forma "x+0"
                        else if (ConstantInt *CI = dyn_cast<ConstantInt>(BinOp->getOperand(1))) {
                            if (CI->isZero()) {
                                Value *X = BinOp->getOperand(0);
                                BinOp->replaceAllUsesWith(X);
                                BinOp->eraseFromParent();
                                return true;
                            }
                        }
                    }
                }
            }
  }


bool runOnFunction(Function &F) {
  bool Transformed = false;

  for (auto Iter = F.begin(); Iter != F.end(); ++Iter) {
    if (runOnBasicBlock(*Iter)) {
      Transformed = true;
    }
  }

  return Transformed;
}


PreservedAnalyses LocalOpts::run(Module &M,
                                      ModuleAnalysisManager &AM) {
  for (auto Fiter = M.begin(); Fiter != M.end(); ++Fiter)
    if (runOnFunction(*Fiter))
      return PreservedAnalyses::none();
  
  return PreservedAnalyses::all();
}
