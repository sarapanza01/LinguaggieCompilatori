/** 
La mia idea per fare il passo 0 è un mix tra il mio passo 1 e il file originale di LocalOpts
**/

#include "llvm/Transforms/Utils/LocalOpts.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/InstrTypes.h"
#include "llvm/IR/Constants.h"

using namespace llvm;

bool runOnBasicBlock(BasicBlock &B) 
{
    //Parto scorrendo tutte le istruzioni del Basic Block
    for (auto &Inst : B)
    {
        //Guardo se è una operazione binaria...
        if (auto *BinOp = dyn_cast<BinaryOperator>(&Inst)) 
        {
            //...del tipo mul
            if (BinOp->getOpcode() == Instruction::Mul) 
            {
              //ora dovrei controllare che il numero costante(ipotizzando si trovi a destra(Right Hand Side) nella operazione) sia un multiplo di due
              if (ConstantInt *CI = dyn_cast<ConstantInt>(BinOp->getOperand(1))) 
              {
                    //uso la variabile di tipo APInt perchè è quello che restituisce la funzione getValue()
                    APInt RHSValue = CI->getValue();
                    //Controllo se è un multiplo di due con la funzione trovata nella classe APInt
                    if (RHSValue.isPowerf2())
                    {
                      //Ora che so se è una potenza di due, devo sostituire l'istruzione con quella dello shift
                      //QUESTE SONO LE ISTRUZIONI DEL PROFESSORE
                      //Manipolazione delle istruzioni
                      //Lo shift è una Bitwise Binary Operation(da https://llvm.org/docs/LangRef.html) quindi la cerco nella documentazione
                      //Trovo che la sigla per rappresentare lo shift è "Shl"
                      //Ora devo trovare di QUANTO devo shiftare, e questo dipende da quale potenza del 2 abbiamo a nel RHS
                        //Vediamo se trovo qualche funzione in APInt, non ho trovato niente, ma posso procedere con un modo più ignorante
                        //Value *RHSNewValue = ( RHSValue % 2 ) Ovviamente non funziona
                       //Mi devo appoggiare ad un altro oggetto, l'IRBuilder
                            IRBuilder<> Builder(Mul);
                            Value *ShiftAmount = Builder.getInt32(RHSValue.logBase2());
                    //Questa istruzione mi sostituisce quella sotto
                            Value *NewShl = Builder.CreateShl(BinOp.getOperand(0), ShiftAmount);
                      //Instruction *NewInst = BinaryOperator::Create(Instruction::Shl, Inst.getOperand(0), RHSNewValue);
                      //NewInst->insertAfter(&Inst); Secondo me questa istruzione non serve per sostituire la mia
                      // Si possono aggiornare le singole references separatamente?
                      // Controlla la documentazione e prova a rispondere.
                      Inst.replaceAllUsesWith(NewInst);
                        //Questa funzione NON SO se è necessaria
                        Inst.eraseFromParent();
                     }
                }
            }
        }
    }
return true;
}


bool runOnFunction(Function &F) {
  bool Transformed = false;

  for (auto Iter = F.begin(); Iter != F.end(); ++Iter) {
    if (runOnBasicBlock(*Iter)) {
      Transformed = true;
    }
  }

  return Transformed;
}


PreservedAnalyses LocalOpts::run(Module &M,
                                      ModuleAnalysisManager &AM) {
  for (auto Fiter = M.begin(); Fiter != M.end(); ++Fiter)
    if (runOnFunction(*Fiter))
      return PreservedAnalyses::none();

  return PreservedAnalyses::all();
}
